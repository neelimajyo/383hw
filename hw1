# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""

import sys
import puzz.py
import pdqpq.py


MAX_SEARCH_ITERS = 100000
GOAL_STATE = puzz.EightPuzzleBoard("012345678")


def solve_puzzle(start_state, strategy):
    """Perform a search to find a solution to a puzzle.
    
    Args:
        start_state: an EightPuzzleBoard object indicating the start state for the search
        flavor: a string indicating which type of search to run.  Can be one of the following:
            'bfs' - breadth-first search
            'ucost' - uniform-cost search
            'greedy-h1' - Greedy best-first search using a misplaced tile count heuristic
            'greedy-h2' - Greedy best-first search using a Manhattan distance heuristic
            'greedy-h3' - Greedy best-first search using a weighted Manhattan distance heuristic
            'astar-h1' - A* search using a misplaced tile count heuristic
            'astar-h2' - A* search using a Manhattan distance heuristic
            'astar-h3' - A* search using a weighted Manhattan distance heuristic
    
    Returns: 
        A dictionary containing describing the search performed, containing the following entries:
            'path' - a list of 2-tuples representing the path from the start state to the goal state 
                (both should be included), with each entry being a (str, EightPuzzleBoard) pair 
                indicating the move and resulting state for each action.  Omitted if the search 
                fails.
            'path_cost' - the total cost of the path, taking into account the costs associated 
                with each state transition.  Omitted if the search fails.
            'frontier_count' - the number of unique states added to the search frontier at any
                point during the search.
            'expanded_count' - the number of unique states removed from the frontier and expanded 
                (i.e. have successors generated).
    """

    results = {
        'path': [],
        'path_cost': 0,
        'frontier_count': 0,
        'expanded_count': 0,
    }
    if strategy == 'bfs':
        results = bfs(start_state,strategy,lambda x,y:0,results)
    elif strategy == 'ucost':
        results = ucost_and_astar(start_state, strategy, lambda x,y:0,results)
    elif strategy[:6] == 'greedy':
        results = greedy(start_state, strategy, heuristic,results)
    elif strategy[:5] == 'astar':
        results = ucost_and_astar(start_state, strategy, heuristic,results)
    # 
    # fill in the function body here
    #
    return results

def backtrace(trace, startState):
    total_cost = 0
    path = [(trace[GOAL_STATE][0],GOAL_STATE)]
    while path[-1][1] != startState:
        temp = trace[path[-1][1]][1]
        x,y = temp.find('0')
        holder = int(path[-1][1]._get_tile(x,y))**2
        total_cost += holder
        if (temp != startState):
            path.append(trace[temp][0], temp) 
        else:
            path.append('start', temp)   
    path.reverse()
    return path, total_cost

def bfs(start_state, strategy, heuristic,results):
    frontier_count = 1
    frontier = pdqpq.PriorityQueue()
    explored_count = set()
    trace = {}
    frontier.add(start_state, heuristic(strategy,start_state))
    while len(frontier)>=1:
        node = frontier.pop()
        if node == GOAL_STATE:
            path,total_cost = backtrace(trace, start_state)
            results['path'] = path
            results['path_cost'] = total_cost
            results['frontier_count'] = frontier_count
            results['expanded_count'] = len(explored_count)
            return results
        explored_count.add(node)
        successors = node.successors()
        for i in successors:
            if (successors[i] not in frontier):
                if (successors[i] not in explored_count):
                    trace[successors[i]] = (i, node)
                    if successors[i] == GOAL_STATE:
                        path,total_cost = backtrace(trace, start_state)
                        results['path'] = path
                        results['path_cost'] = total_cost
                        results['frontier_count'] = frontier_count
                        results['expanded_count'] = len(explored_count)
                        return results
            else:
                frontier.add(successors[i], heuristic(strategy,successors[i]))
                frontier_count+=1
    return {
   results['frontier_count']: frontier_count,
   results['expanded_count']: len(explored_count)
  # return results
   }

def greedy(start_state, strategy, heuristic,results):
    frontier_count = 1
    frontier = pdqpq.PriorityQueue()
    explored_count = set()
    trace = {}
    frontier.add(start_state, heuristic(strategy,start_state))
    while len(frontier)>=1:
        node = frontier.pop()
        if node == GOAL_STATE:
            path,total_cost = backtrace(trace, start_state)
            frontier_count+=1
            results['path'] = path
            results['path_cost'] = total_cost
            results['frontier_count'] = frontier_count
            results['expanded_count'] = len(explored_count)
            return results
        explored_count.add(node)
        successors = node.successors()
        for i in successors:
            if (successors[i] not in frontier):
                if (successors[i] not in explored_count):
                    trace[successors[i]] = (i, node)
                    if successors[i] == GOAL_STATE:
                        frontier_count+=1
                        path,total_cost = backtrace(trace, start_state)
                        results['path'] = path
                        results['path_cost'] = total_cost
                        results['frontier_count'] = frontier_count
                        results['expanded_count'] = len(explored_count)
                        return results
            else:
                frontier.add(successors[i], heuristic(strategy,successors[i]))
                frontier_count+=1
    return {
   results['frontier_count']: frontier_count,
   results['expanded_count']: len(explored_count)
  # return results
   }

def ucost_and_astar(start_state, strategy, heuristic,results):
    trace = {}
    frontier_count = 1
    frontier = pdqpq.PriorityQueue()
    explored_count = set()
    frontier.add(start_state, 0)
    while len(frontier)>=1:
        path_cost = frontier.pq[0][0]
        node = frontier.pop()
        path_cost -= heuristic(strategy, node)
        if node == GOAL_STATE:
            path,_ = backtrace(trace, start_state) 
            results['path'] = path
            results['path_cost'] = path_cost
            results['frontier_count'] = frontier_count
            results['expanded_count'] = len(explored_count)
            return results
        explored_count.add(node)
        successors = node.successors()
        for i in successors:
            x,y = node.find('0')
            holder = int(successors[i]._get_tile(x,y))**2
            node_cost = holder
            heu_cost = heuristic(strategy,successors[i]) 
            if (successors[i] not in frontier):
                if(successors[i] not in explored_count):
                    frontier_count  += 1
                    temp = node_cost+path_cost+heu_cost
                    frontier.add(successors[i], temp)
                    trace[successors[i]] = (i, node)
            elif (successors[i] in frontier):
                if(not frontier.get(successors[i]) <=  node_cost+path_cost+heu_cost):
                    frontier.entry_finder[successors[i]][0] =  node_cost+path_cost+heu_cost
                    trace[successors[i]] = (i, node)
    
    return {
   results['frontier_count']: frontier_count,
   results['expanded_count']: len(explored_count)
  # return results
   }


def heuristic(strategy,state):
    if strategy == 'greedy-h1' or strategy == 'astar-h1':
        stat = '012345678'
        state_str = state.__str__()
        count = 0
        for s1 in stat:
            for i in state_str:
                if(s1 != '0'):
                    if(s1 != i):
                        count+=1
        return count
    else:
        return gh2_ah2_gh3_gh4(strategy,state)
    return 0

def gh2_ah2_gh3_gh4(strategy,state):
    sum = 0
    for s in state._board:
        if s != '0':
            x,y = GOAL_STATE.find(s)
            i,j = state.find(s)
            if strategy == 'greedy-h3' or strategy == 'astar-h3':
                sum+=int(s)**2 * (abs(x-i) + abs(y-j))
            else:
                sum +=abs(x-i)+abs(y-j)
    return sum
#**********************************************************************************
def print_summary(results):
    if 'path' in results:
        print("found solution of length {}, cost {}".format(len(results['path']), 
                                                            results['path_cost']))
        for move, state in results['path']:
            print("  {:5} {}".format(move, state))
    else:
        print("no solution found")
    print("{} states placed on frontier, {} states expanded".format(results['frontier_count'], 
                                                                    results['expanded_count']))


############################################

if __name__ == '__main__':

    start = puzz.EightPuzzleBoard(sys.argv[1])
    method = sys.argv[2]

    print("solving puzzle {} -> {}".format(start, GOAL_STATE))
    results = solve_puzzle(start, method)
    print_summary(results)
